---
title: 秒杀系统设计
toc: true
thumbnail: /images/giant.jpeg
date: 2019-02-05 10:28:56
author: GSM
tags: 架构设计
categories: 架构设计
---
123
<!--more-->
# 秒杀系统本质
秒杀系统本质上是一个满足大并发、高性能和高可用的分布式系统。

秒杀其实主要解决两个问题，一个是并发读，一个是并发写。并发读的核心优化理念是尽量减少用户到服务端来“读”数据，或者让他们读更少的数据；并发写的处理原则也一样，它要求我们在数据库层面独立出来一个库，做特殊的处理。另外，我们还要针对秒杀系统做一些保护，针对意料之外的情况设计兜底方案，以防止最坏的情况发生。

总的来说，架构是一种平衡的艺术，而最好的架构一旦脱离了它所适应的场景，一切都将是空谈。

具体设计应该参照秒杀预估流量：

1. QPS 小于1W：只需要把商品购买页面增加一个定时上架功能，仅在秒杀开始时才让用户看到购买按钮，当商品库存卖完了也就结束了。
2. 随着请求量加大（QPS 1W/s -> 10W/s），这个简单的架构就很快遇到了瓶颈，因此需要做架构改造来提升系统性能。
3. QPS 100W/s 以上

# 怎样设计降低服务压力
## 一、架构设计原则
### 1.数据要尽量少

- 用户请求的数据能少就少。具体包含上传给系统的数据和系统返回给用户的数据。原因是首先这些数据在网络传输需要时间，其数据传输都需要服务器做压缩和字符编码，都非常消耗CPU，所以减少传输的数据量可以显著减少CPU的使用。

- 系统依赖的数据能少就少。依赖的路径越多会增加CPU处理时间（序列化和反序列化），同样会增加延时。

常见设计手段为：动静分离。
#### 动静分离
具体为变刷新整个页面为只点击“秒杀”按钮就够了。动静分离后，客户端大幅度减少了请求的数据量。
分离改造核心：分离出动态数据。 如url唯一化，分离浏览者相关因素，分离时间因素，异步化地域因素，去掉cookie等。

**对静态数据缓存**：1. 静态数据缓存到离用户最近的地方。浏览器、CDN、服务端Cache。2.静态化改造直接缓存HTTP连接 3. Web服务器流入Nginx缓存静态数据优于Tomcat。
**对动态数据缓存**:
1.ESI（edge side includes）服务端拼接动静态内容，组装一起返回，服务端性能有影响，但是客户端体验好
2.CSI（client side include）客户端发起异步js请求，服务端性能好，客户端可能会有延时，体验稍差.

部署架构：

需要解决（失效问题，命中率问题，发布更新问题），其他细节：浏览器缓存和cdn缓存差别很大；合并是否用gzip压缩。

### 2.请求数要尽量少
用户请求的页面返回后，浏览器渲染这个页面还包含其他的额外请求。例如页面依赖的CSS/JS， 图片， Ajax请求等都被定义为“额外请求”，这些额外请求应该尽量少。因为上述每个资源请求都能增加连接（需要做三次握手），可能造成资源串行加载，不同域名还有DNS解析。解决办法：合并CSS/JS文件。

常见设计手段为：流量削峰。

#### 流量削峰
本质上：延缓用户请求的发出。让服务处理更加平稳，节省服务器成本。
削峰基本思路如下：

- 排队：用MQ来缓冲瞬时流量，把同步的直接调用转换成异步的间接推送，中间通过一个队列在一段承接瞬时的流量洪峰，在另一端平滑的将消息推送出去。

除了利用MQ,还可以使用线程池加锁方式实现排队，FIFO内存排队。这样就会存在异步返回结果问题：解决方案有两种1. 客户端轮询，例如支付页面，每秒轮询一次； 2.服务端push结果。需要C/S保持长连接。

- 答题：防作弊，延缓请求。
- 分层过滤：对请求进行分层过滤，从而过滤掉一些无效的请求。分层过滤其实就是采用“漏斗式”设计来处理请求。核心思想为：在不同层次尽量过滤掉无效请求[根据库存判断无法抢到商品的人]，让“漏斗”最末端的才是有效请求。
    + 读系统尽量减少一致性校验的瓶颈，但尽量将不影响性能的检查条件提前
    + 写系统主要对写数据进行一致性检查 

### 3.路径尽量短

路径：用户发出请求到返回数据这个过程中，需要经过的中间节点数。

这是因为每增加一个连接都会增加新的不确定性。从概率统计上说，假如一个请求经过5个节点，每个节点可用性是99.9%的话，那么整个请求的可用性是：99.9的5次方，约等于99.5%。缩短路径不仅可以增加可用性，同样可以有效提升性能（减少中间节点可以减少数据的序列化和反序列化），并减少延时。
有一种缩短访问路径办法: 多个相互强依赖的应用合并部署在一起，把远程调用RPC 变成JVM内部之间的方法调用。

### 4.依赖要尽量少，系统分级

展示秒杀页面，这个页面必须强依赖商品信息、用户信息，还有其他如优惠券、成交列表等这些对秒杀不是非要不可的信息（弱依赖），这些弱依赖在紧急情况下就可以去掉。要减少依赖就必须对系统进行分级。0级系统要尽量减少对1级系统的强依赖，防止重要的系统被不重要的系统拖垮。在极端情况下可以把1级系统例如优惠券系统降级。

### 5.不要有单点

无单点的重点是避免将服务的状态和机器绑定，即把服务无状态化。
应用无状态化是有效避免单点的一种方式，但是像存储服务本身很难无状态话，因为数据要存储在磁盘上，本身就要和机器绑定，那么这种场景只能通过冗余多个备份来解决单点问题。

## 二、热点数据处理
为什么要处理热点数据？热点请求会大量占用服务器处理资源，虽然这个热点可能只占请求总量的亿分之一，然而却可能抢占90%的服务器资源。

什么是热点：热点分为热点操作和热点数据。

- 热点操作，例如大量的刷新页面、大量的添加购物车、双十一零点大量的下单。对系统来说，这些操作可以抽象为“读请求”和“写请求”。热点操作中的写操作将下面单独一节讲解。
- 热点数据：用户的热点请求对应的数据。热点数据分为“静态热点数据”和“动态热点数据”。
  + 静态热点数据：可以提前预测的热点数据。业务场景，通过卖家报名来打标。还可以通过数据分析历史成交记录，用户购物车记录分析出热点商品。
  + 动态热点数据：不能被提前预测的热点数据，系统在运行过程中临时产生的热点。例如上家临时做了广告导致的热点数据。解决方案：构建数据动态发现系统，分析热点Key，数据上报统计。

处理热点数据：
一、优化 ： 缓存。热点数据动静分离。
二、限制 ： 热点数据限制到一个请求队列里，防止热点数据占用太多服务器资源导致其他请求无法处理。
三、隔离

- 系统隔离：分组部署，将热点描述请求分到单独的集群。
- 数据隔离：热点秒杀数据启用单独的Cache/MySQL集群。
- 业务隔离：卖家报名秒杀提前感知热点，做数据预热。

## 三、 性能优化
核心：降低CPU消耗。
### 衡量指标 
```
总QPS = （1000ms / RT） * 线程数量
```
其中线程数量一般默认配置为 2*CPU核数 + 1。

### 优化方法
- 减少编码
- 减少序列化
- 服务优化（如nginx返回静态数据，框架定制优化）
- 并发读优化：应用层的LocalCache，在秒杀系统的单机上缓存商品相关的数据.
- 静态数据（秒杀前全机推静态cache数据）
- 动态数据（类似库存，一般缓存几秒，被动失效，允许一定的脏数据）
- 流程：发现数据，减少短板，数据分级，减少中间环节，做好应用基线（性能基线，成本基线，链路基线）不断调整 

